<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Collaborative Synth / Step Sequencer with Effects</title>
  <!-- Import Google Font -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
  <style>
    /* Global Styles */
    body {
      font-family: 'Roboto', sans-serif;
      margin: 20px;
      background-color: #121212;
      color: #eee;
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
    }
    p {
      text-align: center;
      margin-bottom: 20px;
      font-size: 14px;
      color: #ccc;
    }
    /* Controls */
    #controls, #loop-control {
      text-align: center;
      margin-bottom: 20px;
    }
    #controls label, #loop-control label {
      margin-right: 15px;
      font-size: 14px;
      cursor: pointer;
    }
    #controls input[type="checkbox"] {
      margin-right: 5px;
    }
    /* Sequencer Container */
    #sequencer {
      overflow-x: auto;
      padding: 10px;
      background-color: #1e1e1e;
      border: 1px solid #333;
      border-radius: 8px;
      max-width: 100%;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    /* Instrument Row Layout */
    .instrument-row {
      display: grid;
      grid-template-columns: 120px auto;
      align-items: center;
      margin-bottom: 8px;
    }
    .instrument-label {
      text-align: right;
      font-weight: 700;
      padding-right: 10px;
      font-size: 16px;
    }
    .instrument-grid {
      display: grid;
      grid-template-columns: repeat(64, 30px);
      grid-gap: 4px;
    }
    /* Grid Cell Styles */
    .cell {
      width: 30px;
      height: 30px;
      background-color: #2d2d2d;
      border: 1px solid #444;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    /* Every 4th cell (columns 1, 5, 9, …) gets a slightly different background */
    .instrument-grid .cell:nth-child(4n+1):not(.active) {
      background-color: #383838;
    }
    .cell.active {
      background-color: #00e676;
      box-shadow: 0 0 8px #00e676;
    }
    .cell:hover {
      box-shadow: 0 0 8px rgba(0, 230, 118, 0.5);
    }
    /* Current Column Highlight */
    .cell.current::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: 2px solid #ff4081;
      border-radius: 4px;
      box-sizing: border-box;
      pointer-events: none;
    }
    /* Dim cells that are outside the selected loop length */
    .cell.disabled {
      opacity: 0.3;
    }
  </style>
</head>
<body>
  <h1>Collaborative Synth / Step Sequencer</h1>
  <p>Click a cell to toggle it. Changes are shared in real time with all connected users.</p>

  <!-- Effects Controls -->
  <div id="controls">
    <label>
      <input type="checkbox" id="filterToggle"> Enable Filter
    </label>
    <label>
      <input type="checkbox" id="reverbToggle"> Enable Reverb
    </label>
  </div>

  <!-- Loop Length Control -->
  <div id="loop-control">
    <label for="loopLength">Loop Length:</label>
    <select id="loopLength">
      <option value="8">8</option>
      <option value="16">16</option>
      <option value="32">32</option>
      <option value="64" selected>64</option>
    </select>
  </div>

  <!-- Sequencer Container -->
  <div id="sequencer">
    <!-- Instrument rows will be generated dynamically -->
  </div>

  <script>
    // ============================================
    // Audio Setup & Effects
    // ============================================
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Global effect toggles
    let filterEnabled = false;
    let reverbEnabled = false;

    // Set up control event listeners for effects
    document.getElementById("filterToggle").addEventListener("change", function() {
      filterEnabled = this.checked;
    });
    document.getElementById("reverbToggle").addEventListener("change", function() {
      reverbEnabled = this.checked;
    });

    // Create a simple impulse response for reverb (2 seconds, decay factor 2)
    function createReverbImpulseResponse(duration, decay) {
      const sampleRate = audioContext.sampleRate;
      const length = sampleRate * duration;
      const impulse = audioContext.createBuffer(2, length, sampleRate);
      for (let channel = 0; channel < 2; channel++) {
        const impulseChannel = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          impulseChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
      }
      return impulse;
    }

    // Global reverb convolver node; connect it permanently to the destination.
    const reverbNode = audioContext.createConvolver();
    reverbNode.buffer = createReverbImpulseResponse(2.0, 2.0);
    reverbNode.connect(audioContext.destination);

    // Helper function to build the effects chain and connect to destination.
    function connectEffects(gainNode, time) {
      let outputNode = gainNode;
      if (filterEnabled) {
        const filterNode = audioContext.createBiquadFilter();
        filterNode.type = 'lowpass';
        filterNode.frequency.setValueAtTime(800, time);
        outputNode.connect(filterNode);
        outputNode = filterNode;
      }
      if (reverbEnabled) {
        outputNode.connect(reverbNode);
      } else {
        outputNode.connect(audioContext.destination);
      }
    }

    // Play an oscillator sound with an envelope and applied effects.
    function playOscillator(time, frequency, waveform, duration = 0.1) {
      const osc = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      osc.frequency.setValueAtTime(frequency, time);
      osc.type = waveform;
      osc.connect(gainNode);
      gainNode.gain.setValueAtTime(1, time);
      gainNode.gain.exponentialRampToValueAtTime(0.001, time + duration);
      connectEffects(gainNode, time);
      osc.start(time);
      osc.stop(time + duration);
    }

    // Play a burst of white noise with an envelope and applied effects.
    function playNoise(time, duration = 0.1, volume = 0.3) {
      const bufferSize = audioContext.sampleRate * duration;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;
      const gainNode = audioContext.createGain();
      noise.connect(gainNode);
      gainNode.gain.setValueAtTime(volume, time);
      gainNode.gain.exponentialRampToValueAtTime(0.001, time + duration);
      connectEffects(gainNode, time);
      noise.start(time);
      noise.stop(time + duration);
    }

    // Play the instrument sound based on its name.
    function playInstrument(instrument, time) {
      switch(instrument) {
        case "lead":
          playOscillator(time, 440, "sawtooth", 0.15);
          break;
        case "brass":
          playOscillator(time, 330, "square", 0.15);
          break;
        case "keys":
          playOscillator(time, 523, "triangle", 0.15);
          break;
        case "drums":
          playOscillator(time, 100, "sine", 0.2);
          break;
        case "claps":
          playNoise(time, 0.1, 0.5);
          break;
        case "hihat":
          playNoise(time, 0.05, 0.3);
          break;
        case "bass":
          playOscillator(time, 110, "sine", 0.2);
          break;
        case "bells":
          playOscillator(time, 660, "sine", 0.2);
          break;
        case "percussion":
          playOscillator(time, 220, "sine", 0.15);
          break;
        case "Kick":
          playOscillator(time, 80, "sine", 0.25);
          break;
        case "plucks":
          playOscillator(time, 350, "triangle", 0.15);
          break;
        default:
          break;
      }
    }

    // ============================================
    // Sequencer Grid & UI Setup
    // ============================================
    // Instruments (rows) including the two new instruments.
    const rowNames = [
      "lead", "brass", "keys", "drums", "claps",
      "hihat", "bass", "bells", "percussion",
      "Kick", "plucks"
    ];
    const rows = rowNames.length;
    const cols = 64;  // The grid always has 64 columns

    // Sequencer timing: 100 BPM → 0.6 sec per beat, 0.15 sec per 16th note.
    const BPM = 100;
    const secondsPerBeat = 60 / BPM;
    const stepInterval = secondsPerBeat / 4;  // 16th-note duration

    // Loop length control – only steps 0..(loopLength-1) will be played.
    let loopLength = 64;
    const loopLengthSelect = document.getElementById("loopLength");
    loopLengthSelect.addEventListener("change", function() {
      loopLength = parseInt(this.value);
      updateLoopColumns();
    });

    // Grid state: a 2D array [row][col] (all initially false)
    const gridState = [];
    // Create the sequencer rows in the UI.
    const sequencerElement = document.getElementById("sequencer");
    for (let i = 0; i < rows; i++) {
      gridState[i] = [];
      const rowDiv = document.createElement("div");
      rowDiv.classList.add("instrument-row");
      const labelDiv = document.createElement("div");
      labelDiv.classList.add("instrument-label");
      labelDiv.innerText = rowNames[i];
      rowDiv.appendChild(labelDiv);
      const rowGrid = document.createElement("div");
      rowGrid.classList.add("instrument-grid");
      for (let j = 0; j < cols; j++) {
        gridState[i][j] = false;
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.dataset.row = i;
        cell.dataset.col = j;
        cell.addEventListener("click", () => {
          gridState[i][j] = !gridState[i][j];
          cell.classList.toggle("active", gridState[i][j]);
          // Broadcast the change.
          const message = {
            type: "toggle",
            row: i,
            col: j,
            value: gridState[i][j]
          };
          ws.send(JSON.stringify(message));
        });
        rowGrid.appendChild(cell);
      }
      rowDiv.appendChild(rowGrid);
      sequencerElement.appendChild(rowDiv);
    }
    // Mark columns outside the current loop length as disabled.
    function updateLoopColumns() {
      document.querySelectorAll('.cell').forEach(cell => {
        const col = parseInt(cell.dataset.col);
        if (col >= loopLength) {
          cell.classList.add("disabled");
        } else {
          cell.classList.remove("disabled");
        }
      });
    }
    // Initial update so that if loopLength is less than 64, the extra columns are dimmed.
    updateLoopColumns();

    // ============================================
    // Sequencer Scheduler
    // ============================================
    let currentStep = 0;
    function scheduler() {
      const currentTime = audioContext.currentTime;
      for (let row = 0; row < rows; row++) {
        if (gridState[row][currentStep]) {
          playInstrument(rowNames[row], currentTime);
        }
      }
      highlightColumn(currentStep);
      currentStep = (currentStep + 1) % loopLength;
    }
    function highlightColumn(step) {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.classList.remove('current');
      });
      document.querySelectorAll(`.cell[data-col="${step}"]`).forEach(cell => {
        cell.classList.add('current');
      });
    }
    setInterval(scheduler, stepInterval * 1000);

    // ============================================
    // WebSocket for Collaborative Sync & Initial State
    // ============================================
    const ws = new WebSocket("ws://" + window.location.host + "/ws");
    ws.onopen = function() {
      console.log("Connected to the WebSocket server.");
      // Request the current board state.
      ws.send(JSON.stringify({ type: "get_state" }));
    };
    ws.onmessage = function(event) {
      const message = JSON.parse(event.data);
      if (message.type === "init") {
        // Initialize the gridState with the state sent by the server.
        for (let i = 0; i < rows; i++) {
          gridState[i] = message.gridState[i];
        }
        // Update the UI for each cell.
        document.querySelectorAll('.cell').forEach(cell => {
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          cell.classList.toggle("active", gridState[row][col]);
        });
      } else if (message.type === "toggle") {
        const { row, col, value } = message;
        gridState[row][col] = value;
        document.querySelectorAll(`.cell[data-row="${row}"][data-col="${col}"]`)
          .forEach(cell => {
            cell.classList.toggle("active", value);
          });
      }
    };
    ws.onclose = function() {
      console.log("Disconnected from the WebSocket server.");
    };
  </script>
</body>
</html>

