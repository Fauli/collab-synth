<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Collaborative Synth / Step Sequencer with Parameters</title>
  <!-- Import Google Font -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
  <style>
    /* Global Styles */
    body {
      font-family: 'Roboto', sans-serif;
      margin: 20px;
      background-color: #121212;
      color: #eee;
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
    }
    p {
      text-align: center;
      margin-bottom: 20px;
      font-size: 14px;
      color: #ccc;
    }
    /* Controls */
    #controls, #loop-control, #params {
      text-align: center;
      margin-bottom: 20px;
    }
    #controls label, #loop-control label, #params label {
      margin-right: 15px;
      font-size: 14px;
      cursor: pointer;
    }
    #controls input[type="checkbox"] {
      margin-right: 5px;
    }
    /* Parameter slider styles */
    #params label {
      display: inline-block;
      margin: 0 10px;
    }
    #params input[type="range"] {
      vertical-align: middle;
    }
    /* Sequencer Container */
    #sequencer {
      overflow-x: auto;
      padding: 10px;
      background-color: #1e1e1e;
      border: 1px solid #333;
      border-radius: 8px;
      max-width: 100%;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    /* Instrument Row Layout */
    .instrument-row {
      display: grid;
      grid-template-columns: 120px auto;
      align-items: center;
      margin-bottom: 8px;
    }
    .instrument-label {
      text-align: right;
      font-weight: 700;
      padding-right: 10px;
      font-size: 16px;
    }
    .instrument-grid {
      display: grid;
      grid-template-columns: repeat(64, 30px);
      grid-gap: 4px;
    }
    /* Grid Cell Styles */
    .cell {
      width: 30px;
      height: 30px;
      background-color: #2d2d2d;
      border: 1px solid #444;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s, box-shadow 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    /* Every 4th cell gets a slightly different background */
    .instrument-grid .cell:nth-child(4n+1):not(.active) {
      background-color: #383838;
    }
    .cell.active {
      background-color: #00e676;
      box-shadow: 0 0 8px #00e676;
    }
    .cell:hover {
      box-shadow: 0 0 8px rgba(0, 230, 118, 0.5);
    }
    /* Current Column Highlight */
    .cell.current::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: 2px solid #ff4081;
      border-radius: 4px;
      box-sizing: border-box;
      pointer-events: none;
    }
    /* Dim cells outside the current loop length */
    .cell.disabled {
      opacity: 0.3;
    }
    /* Overlay to unlock audio */
    #startOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 9999;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="startOverlay">Tap to Start Audio</div>
  <h1>Collaborative Synth / Step Sequencer</h1>
  <p>Click a cell to toggle it. Changes are shared in real time with all connected users.</p>

  <!-- Effects Controls -->
  <div id="controls">
    <label>
      <input type="checkbox" id="filterToggle"> Enable Filter
    </label>
    <label>
      <input type="checkbox" id="reverbToggle"> Enable Reverb
    </label>
  </div>

  <!-- Loop Length Control -->
  <div id="loop-control">
    <label for="loopLength">Loop Length:</label>
    <select id="loopLength">
      <option value="8">8</option>
      <option value="16">16</option>
      <option value="32">32</option>
      <option value="64" selected>64</option>
    </select>
  </div>

  <!-- Parameter Automation Controls -->
  <div id="params">
    <label>
      Filter Cutoff: <span id="filterCutoffValue">800</span> Hz
      <input type="range" id="filterCutoff" min="100" max="5000" step="10" value="800">
    </label>
    <label>
      Filter Q: <span id="filterQValue">1.0</span>
      <input type="range" id="filterQ" min="0.5" max="10" step="0.1" value="1.0">
    </label>
    <label>
      Reverb Decay: <span id="reverbDecayValue">2.0</span> s
      <input type="range" id="reverbDecay" min="0.5" max="5" step="0.1" value="2.0">
    </label>
    <label>
      Volume: <span id="volumeValue">1.0</span>
      <input type="range" id="volume" min="0" max="1" step="0.01" value="1.0">
    </label>
  </div>

  <!-- Sequencer Container -->
  <div id="sequencer">
    <!-- Instrument rows will be generated dynamically -->
  </div>

  <script>
    // --- Unlock Audio on User Gesture ---
    const startOverlay = document.getElementById("startOverlay");
    startOverlay.addEventListener("click", () => {
      // Resume the audio context.
      audioContext.resume().then(() => {
        startOverlay.style.display = "none";
      });
    });

    // ============================================
    // Audio Setup & Effects with Parameter Automation
    // ============================================
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // Global effect toggles
    let filterEnabled = false;
    let reverbEnabled = false;

    // Global parameters with default values.
    let filterCutoff = 800;
    let filterQ = 1.0;
    let reverbDecay = 2.0;
    let volume = 1.0;

    // Create a master gain node for volume control.
    const masterGain = audioContext.createGain();
    masterGain.gain.setValueAtTime(volume, audioContext.currentTime);
    masterGain.connect(audioContext.destination);

    // Set up control event listeners for effects.
    document.getElementById("filterToggle").addEventListener("change", function() {
      filterEnabled = this.checked;
    });
    document.getElementById("reverbToggle").addEventListener("change", function() {
      reverbEnabled = this.checked;
    });

    // Parameter controls.
    const filterCutoffSlider = document.getElementById("filterCutoff");
    const filterQSlider = document.getElementById("filterQ");
    const reverbDecaySlider = document.getElementById("reverbDecay");
    const volumeSlider = document.getElementById("volume");

    // Display spans.
    const filterCutoffValueSpan = document.getElementById("filterCutoffValue");
    const filterQValueSpan = document.getElementById("filterQValue");
    const reverbDecayValueSpan = document.getElementById("reverbDecayValue");
    const volumeValueSpan = document.getElementById("volumeValue");

    // When parameters change, update globals, UI, audio nodes, and notify others.
    function updateParam(param, value) {
      switch(param) {
        case "filterCutoff":
          filterCutoff = value;
          filterCutoffValueSpan.innerText = value;
          break;
        case "filterQ":
          filterQ = value;
          filterQValueSpan.innerText = value;
          break;
        case "reverbDecay":
          reverbDecay = value;
          reverbDecayValueSpan.innerText = value;
          // Rebuild the impulse response for the reverb.
          reverbNode.buffer = createReverbImpulseResponse(reverbDecay, 2.0);
          break;
        case "volume":
          volume = value;
          volumeValueSpan.innerText = value;
          masterGain.gain.setValueAtTime(volume, audioContext.currentTime);
          break;
      }
      // Send parameter update to backend.
      const msg = {
        type: "set_param",
        param: param,
        paramValue: value
      };
      ws.send(JSON.stringify(msg));
    }

    filterCutoffSlider.addEventListener("input", (e) => {
      updateParam("filterCutoff", parseFloat(e.target.value));
    });
    filterQSlider.addEventListener("input", (e) => {
      updateParam("filterQ", parseFloat(e.target.value));
    });
    reverbDecaySlider.addEventListener("input", (e) => {
      updateParam("reverbDecay", parseFloat(e.target.value));
    });
    volumeSlider.addEventListener("input", (e) => {
      updateParam("volume", parseFloat(e.target.value));
    });

    // Create a simple impulse response for reverb.
    function createReverbImpulseResponse(duration, decay) {
      const sampleRate = audioContext.sampleRate;
      const length = sampleRate * duration;
      const impulse = audioContext.createBuffer(2, length, sampleRate);
      for (let channel = 0; channel < 2; channel++) {
        const impulseChannel = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          impulseChannel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
      }
      return impulse;
    }

    // Global reverb node.
    const reverbNode = audioContext.createConvolver();
    reverbNode.buffer = createReverbImpulseResponse(reverbDecay, 2.0);
    reverbNode.connect(masterGain);

    // Helper function to build the effects chain.
    function connectEffects(gainNode, time) {
      let outputNode = gainNode;
      if (filterEnabled) {
        const filterNode = audioContext.createBiquadFilter();
        filterNode.type = 'lowpass';
        filterNode.frequency.setValueAtTime(filterCutoff, time);
        filterNode.Q.setValueAtTime(filterQ, time);
        outputNode.connect(filterNode);
        outputNode = filterNode;
      }
      if (reverbEnabled) {
        outputNode.connect(reverbNode);
      } else {
        outputNode.connect(masterGain);
      }
    }

    // Play an oscillator sound with envelope and applied effects.
    function playOscillator(time, frequency, waveform, duration = 0.1) {
      const osc = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      osc.frequency.setValueAtTime(frequency, time);
      osc.type = waveform;
      osc.connect(gainNode);
      gainNode.gain.setValueAtTime(1, time);
      gainNode.gain.exponentialRampToValueAtTime(0.001, time + duration);
      connectEffects(gainNode, time);
      osc.start(time);
      osc.stop(time + duration);
    }

    // Play a burst of white noise with envelope and applied effects.
    function playNoise(time, duration = 0.1, vol = 0.3) {
      const bufferSize = audioContext.sampleRate * duration;
      const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      const noise = audioContext.createBufferSource();
      noise.buffer = buffer;
      const gainNode = audioContext.createGain();
      noise.connect(gainNode);
      gainNode.gain.setValueAtTime(vol, time);
      gainNode.gain.exponentialRampToValueAtTime(0.001, time + duration);
      connectEffects(gainNode, time);
      noise.start(time);
      noise.stop(time + duration);
    }

    // Play instrument sounds.
    function playInstrument(instrument, time) {
      switch(instrument) {
        case "lead":
          playOscillator(time, 440, "sawtooth", 0.15);
          break;
        case "brass":
          playOscillator(time, 330, "square", 0.15);
          break;
        case "keys":
          playOscillator(time, 523, "triangle", 0.15);
          break;
        case "drums":
          playOscillator(time, 100, "sine", 0.2);
          break;
        case "claps":
          playNoise(time, 0.1, 0.5);
          break;
        case "hihat":
          playNoise(time, 0.05, 0.3);
          break;
        case "bass":
          playOscillator(time, 110, "sine", 0.2);
          break;
        case "bells":
          playOscillator(time, 660, "sine", 0.2);
          break;
        case "percussion":
          playOscillator(time, 220, "sine", 0.15);
          break;
        case "Kick":
          playOscillator(time, 80, "sine", 0.25);
          break;
        case "plucks":
          playOscillator(time, 350, "triangle", 0.15);
          break;
        default:
          break;
      }
    }

    // ============================================
    // Sequencer Grid & UI Setup (Board State)
    // ============================================
    const rowNames = [
      "lead", "brass", "keys", "drums", "claps",
      "hihat", "bass", "bells", "percussion",
      "Kick", "plucks"
    ];
    const rows = rowNames.length;
    const cols = 64; // The grid always has 64 columns

    const BPM = 100;
    const secondsPerBeat = 60 / BPM;
    const stepInterval = secondsPerBeat / 4; // 16th note duration

    // Loop Length Control – default to 64.
    const loopLengthSelect = document.getElementById("loopLength");
    // Explicitly set the dropdown's value to "64" on page load.
    loopLengthSelect.value = "64";
    let loopLength = parseInt(loopLengthSelect.value);
    
    loopLengthSelect.addEventListener("change", function() {
      loopLength = parseInt(this.value);
      updateLoopColumns();
    });

    function updateLoopColumns() {
      document.querySelectorAll('.cell').forEach(cell => {
        const col = parseInt(cell.dataset.col);
        if (col >= loopLength) {
          cell.classList.add("disabled");
        } else {
          cell.classList.remove("disabled");
        }
      });
    }
    updateLoopColumns();

    // Create a 2D grid state (initially all false) and build the UI.
    const gridState = [];
    const sequencerElement = document.getElementById("sequencer");
    for (let i = 0; i < rows; i++) {
      gridState[i] = [];
      const rowDiv = document.createElement("div");
      rowDiv.classList.add("instrument-row");
      const labelDiv = document.createElement("div");
      labelDiv.classList.add("instrument-label");
      labelDiv.innerText = rowNames[i];
      rowDiv.appendChild(labelDiv);
      const rowGrid = document.createElement("div");
      rowGrid.classList.add("instrument-grid");
      for (let j = 0; j < cols; j++) {
        gridState[i][j] = false;
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.dataset.row = i;
        cell.dataset.col = j;
        cell.addEventListener("click", () => {
          gridState[i][j] = !gridState[i][j];
          cell.classList.toggle("active", gridState[i][j]);
          const msg = {
            type: "toggle",
            row: i,
            col: j,
            value: gridState[i][j]
          };
          ws.send(JSON.stringify(msg));
        });
        rowGrid.appendChild(cell);
      }
      rowDiv.appendChild(rowGrid);
      sequencerElement.appendChild(rowDiv);
    }

    // ============================================
    // Sequencer Scheduler
    // ============================================
    let currentStep = 0;
    function scheduler() {
      const currentTime = audioContext.currentTime;
      for (let row = 0; row < rows; row++) {
        if (gridState[row][currentStep]) {
          playInstrument(rowNames[row], currentTime);
        }
      }
      highlightColumn(currentStep);
      currentStep = (currentStep + 1) % loopLength;
    }
    function highlightColumn(step) {
      document.querySelectorAll('.cell').forEach(cell => {
        cell.classList.remove('current');
      });
      document.querySelectorAll(`.cell[data-col="${step}"]`).forEach(cell => {
        cell.classList.add('current');
      });
    }
    setInterval(scheduler, stepInterval * 1000);

    // ============================================
    // WebSocket for Collaborative Sync & Initial State
    // ============================================
    const ws = new WebSocket("ws://" + window.location.host + "/ws");
    ws.onopen = function() {
      console.log("Connected to the WebSocket server.");
      ws.send(JSON.stringify({ type: "get_state" }));
    };
    ws.onmessage = function(event) {
      const message = JSON.parse(event.data);
      if (message.type === "init") {
        // Initialize board state and parameters.
        for (let i = 0; i < rows; i++) {
          gridState[i] = message.gridState[i];
        }
        document.querySelectorAll('.cell').forEach(cell => {
          const row = parseInt(cell.dataset.row);
          const col = parseInt(cell.dataset.col);
          cell.classList.toggle("active", gridState[row][col]);
        });
        if (message.params) {
          filterCutoff = message.params.filterCutoff;
          filterQ = message.params.filterQ;
          reverbDecay = message.params.reverbDecay;
          volume = message.params.volume;
          filterCutoffSlider.value = filterCutoff;
          filterCutoffValueSpan.innerText = filterCutoff;
          filterQSlider.value = filterQ;
          filterQValueSpan.innerText = filterQ;
          reverbDecaySlider.value = reverbDecay;
          reverbDecayValueSpan.innerText = reverbDecay;
          volumeSlider.value = volume;
          volumeValueSpan.innerText = volume;
          masterGain.gain.setValueAtTime(volume, audioContext.currentTime);
          reverbNode.buffer = createReverbImpulseResponse(reverbDecay, 2.0);
        }
      } else if (message.type === "toggle") {
        const { row, col, value, userColor } = message;
        gridState[row][col] = value;
        document.querySelectorAll(`.cell[data-row="${row}"][data-col="${col}"]`)
          .forEach(cell => {
            cell.classList.toggle("active", value);
            if (userColor) {
              cell.style.border = `2px solid ${userColor}`;
              setTimeout(() => {
                cell.style.border = "";
              }, 1000);
            }
          });
      } else if (message.type === "param_update") {
        const params = message.params;
        if (params) {
          filterCutoff = params.filterCutoff;
          filterQ = params.filterQ;
          reverbDecay = params.reverbDecay;
          volume = params.volume;
          filterCutoffSlider.value = filterCutoff;
          filterCutoffValueSpan.innerText = filterCutoff;
          filterQSlider.value = filterQ;
          filterQValueSpan.innerText = filterQ;
          reverbDecaySlider.value = reverbDecay;
          reverbDecayValueSpan.innerText = reverbDecay;
          volumeSlider.value = volume;
          volumeValueSpan.innerText = volume;
          masterGain.gain.setValueAtTime(volume, audioContext.currentTime);
          reverbNode.buffer = createReverbImpulseResponse(reverbDecay, 2.0);
        }
      }
    };
    ws.onclose = function() {
      console.log("Disconnected from the WebSocket server.");
    };
  </script>
</body>
</html>

